import logging
from concurrent.futures import ThreadPoolExecutor
from blackstone.pipeline.abbreviations import AbbreviationDetector
from blackstone.pipeline.compound_cases import CompoundCases
from blackstone.utils.legislation_linker import extract_legislation_relations
from blackstone.pipeline.sentence_segmenter import SentenceSegmenter
from blackstone.rules import CITATION_PATTERNS

import grpc
import spacy
import json


from bstone_pb2 import BstoneCompoundReferencesResponse, BstoneCategoriesResponse, BstoneEntitiesResponse, BstoneAbbreviationsResponse
from bstone_pb2_grpc import BstoneServicer, add_BstoneServicer_to_server

nlp = spacy.load("en_blackstone_proto")
sentence_segmenter = SentenceSegmenter(nlp.vocab, CITATION_PATTERNS)
nlp.add_pipe(sentence_segmenter, before="parser")
abbreviation_pipe = AbbreviationDetector(nlp)
nlp.add_pipe(abbreviation_pipe)
compound_pipe = CompoundCases(nlp)
nlp.add_pipe(compound_pipe)


def get_top_cat(doc):
    """
    Function to identify the highest scoring category
    prediction generated by the text categoriser.
    """
    cats = doc.cats
    max_score = max(cats.values())
    max_cats = [k for k, v in cats.items() if v == max_score]
    max_cat = max_cats[0]
    return (max_cat, max_score)


class BstoneServer(BstoneServicer):
    def CompoundReferences(self, request, context):
        res = []
        doc = nlp(request.text)
        for compound_ref in doc._.compound_cases:
            res.append(compound_ref)
        resp = BstoneCompoundReferencesResponse(references=res)
        return resp
    def Abbreviations(self, request, context):
        res = []
        doc = nlp(request.text)
        for abrv in doc._.abbreviations:
            res.append({"abrv": abrv.text, "start": abrv.start, "end": abrv.end, "longForm": abrv._.long_form})
        resp = BstoneAbbreviationsResponse(abbreviations=res)
        return resp
    def Categories(self, request, context):
        res = []
        doc = nlp(request.text)
        sentences = [sent.text for sent in doc.sents]
        for sentence in sentences:
            doc = nlp(sentence)
            cat, conf = get_top_cat(doc)
            res.append({"sentence": sentence, "category": cat, "confidence": conf})
        resp = BstoneCategorizationResponse(categories=res)
        return resp
    def Entities(self, request, context):
        res = []
        doc = nlp(request.text)
        for ent in doc.ents:
            res.append({"text": ent.text, "label": ent.label_})
        resp = BstoneEntitiesResponse(entities=res)
        return resp


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(
        description="Create a Blackstone gRPC server")
    parser.add_argument("-p", "--port", type=int,
                        help="Port number that the server should run on", default=9999)
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
    )
    args = parser.parse_args()
    server = grpc.server(ThreadPoolExecutor())
    add_BstoneServicer_to_server(BstoneServer(), server)
    port = args.port
    server.add_insecure_port(f'[::]:{port}')
    server.start()
    logging.info('server ready on port %r', port)
    server.wait_for_termination()